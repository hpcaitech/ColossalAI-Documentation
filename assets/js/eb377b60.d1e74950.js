"use strict";(self.webpackChunkdemo=self.webpackChunkdemo||[]).push([[4915],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>f});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=o.createContext({}),p=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=p(e.components);return o.createElement(s.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),d=p(n),u=a,f=d["".concat(s,".").concat(u)]||d[u]||c[u]||r;return n?o.createElement(f,i(i({ref:t},m),{},{components:n})):o.createElement(f,i({ref:t},m))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:a,i[1]=l;for(var p=2;p<r;p++)i[p]=n[p];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9802:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var o=n(7462),a=(n(7294),n(3905));const r={},i=void 0,l={unversionedId:"features/nvme_offload",id:"features/nvme_offload",title:"nvme_offload",description:"Author: Hongxin Liu",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/features/nvme_offload.md",sourceDirName:"features",slug:"/features/nvme_offload",permalink:"/docs/features/nvme_offload",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/features/nvme_offload.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Pipeline Parallel",permalink:"/docs/features/pipeline_parallel"},next:{title:"Train ViT Using Pipeline Parallelism",permalink:"/docs/advanced_tutorials/train_vit_using_pipeline_parallelism"}},s={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Usage",id:"usage",level:2},{value:"Exampls",id:"exampls",level:2},{value:"API Reference",id:"api-reference",level:2}],m={toc:p},d="wrapper";function c(e){let{components:t,...n}=e;return(0,a.kt)(d,(0,o.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"nvme-offload"},"NVMe offload"),(0,a.kt)("p",null,"Author: Hongxin Liu"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Prerequisite:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/docs/features/zero_with_chunk"},"Zero Redundancy Optimizer with chunk-based memory management"))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Related Paper")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://arxiv.org/abs/2101.06840"},"ZeRO-Offload: Democratizing Billion-Scale Model Training")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://arxiv.org/abs/2104.07857"},"ZeRO-Infinity: Breaking the GPU Memory Wall for Extreme Scale Deep Learning"))),(0,a.kt)("h2",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"If a model has ",(0,a.kt)("inlineCode",{parentName:"p"},"N")," parameters, when using Adam, it has ",(0,a.kt)("inlineCode",{parentName:"p"},"8N")," optimizer states. For billion-scale models, optimizer states take at least 32 GB memory. GPU memory limits the model scale we can train, which is called GPU memory wall. If we offload optimizer states to the disk, we can break through GPU memory wall."),(0,a.kt)("p",null,"We implement a user-friendly and efficient asynchronous Tensor I/O library: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/hpcaitech/TensorNVMe"},"TensorNVMe"),". With this library, we can simply implement NVMe offload."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"This library is compatible with all kinds of disk (HDD, SATA SSD, and NVMe SSD). As I/O bandwidth of HDD or SATA SSD is low, it's recommended to use this lib only on NVMe disk.")),(0,a.kt)("p",null,"When optimizing a parameter, we can divide the optimization process into three stages: read, compute and offload. We perform the optimization process in a pipelined fashion, which can overlap computation and I/O."),(0,a.kt)("figure",{style:{textAlign:"center"}},(0,a.kt)("img",{src:"https://s2.loli.net/2022/08/16/CvRnowrsNyB4hza.jpg"}),(0,a.kt)("figcaption",null,"Optimization process")),(0,a.kt)("h2",{id:"usage"},"Usage"),(0,a.kt)("p",null,"First, please make sure you installed ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/hpcaitech/TensorNVMe"},"TensorNVMe"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"pip install packaging\npip install tensornvme\n")),(0,a.kt)("p",null,"We implement NVMe offload of optimizer states for Adam (",(0,a.kt)("a",{parentName:"p",href:"https://colossalai.readthedocs.io/en/latest/colossalai/colossalai.nn.optimizer.cpu_adam.html"},"CPUAdam")," and ",(0,a.kt)("a",{parentName:"p",href:"https://colossalai.readthedocs.io/en/latest/colossalai/colossalai.nn.optimizer.hybrid_adam.html"},"HybridAdam"),")."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"from colossalai.nn.optimizer import CPUAdam, HybridAdam\n\noptimizer = HybridAdam(model.parameters(), lr=1e-3, nvme_offload_fraction=1.0, nvme_offload_dir='./')\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"nvme_offload_fraction")," is the fraction of optimizer states to be offloaded to NVMe. ",(0,a.kt)("inlineCode",{parentName:"p"},"nvme_offload_dir")," is the directory to save NVMe offload files. If ",(0,a.kt)("inlineCode",{parentName:"p"},"nvme_offload_dir")," is ",(0,a.kt)("inlineCode",{parentName:"p"},"None"),", a random temporary directory will be used."),(0,a.kt)("p",null,"It's compatible with all parallel methods in ColossalAI."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"\u26a0 It only offloads optimizer states on CPU. This means it only affects CPU training or Zero/Gemini with offloading.")),(0,a.kt)("h2",{id:"exampls"},"Exampls"),(0,a.kt)("p",null,"Let's start from two simple examples -- training GPT with different methods. These examples relies on ",(0,a.kt)("inlineCode",{parentName:"p"},"transformers"),"."),(0,a.kt)("p",null,"We should install denpendencies first:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"pip install psutil transformers\n")),(0,a.kt)("p",null,"First, we import essential packages and modules:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"import os\nimport time\nfrom typing import Dict, Optional\n\nimport psutil\nimport torch\nimport torch.nn as nn\nfrom transformers.models.gpt2.configuration_gpt2 import GPT2Config\nfrom transformers.models.gpt2.modeling_gpt2 import GPT2LMHeadModel\n\nimport colossalai\nfrom colossalai.nn.optimizer import HybridAdam\nfrom colossalai.nn.parallel import zero_model_wrapper, zero_optim_wrapper\nfrom colossalai.utils.model.colo_init_context import ColoInitContext\n")),(0,a.kt)("p",null,"Then we define a loss function:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"class GPTLMLoss(nn.Module):\n\n    def __init__(self):\n        super().__init__()\n        self.loss_fn = nn.CrossEntropyLoss()\n\n    def forward(self, logits, labels):\n        shift_logits = logits[..., :-1, :].contiguous()\n        shift_labels = labels[..., 1:].contiguous()\n        # Flatten the tokens\n        return self.loss_fn(shift_logits.view(-1, shift_logits.size(-1)),\n                            shift_labels.view(-1))\n")),(0,a.kt)("p",null,"And we define some utility functions, which generates random data, computes the number of paramters of a model and get memory usage of current process:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def get_data(batch_size: int, seq_len: int,\n             vocab_size: int, device: Optional[str] = None) -> Dict[str, torch.Tensor]:\n    device = torch.cuda.current_device() if device is None else device\n    input_ids = torch.randint(vocab_size, (batch_size, seq_len),\n                              device=device)\n    attn_mask = torch.ones_like(input_ids)\n    return dict(input_ids=input_ids, attention_mask=attn_mask)\n\n\ndef get_model_numel(model: nn.Module) -> int:\n    return sum(p.numel() for p in model.parameters())\n\n\ndef get_mem_usage() -> int:\n    proc = psutil.Process(os.getpid())\n    return proc.memory_info().rss\n")),(0,a.kt)("p",null,"We first try to train GPT model on CPU:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def train_cpu(nvme_offload_fraction: float = 0.0):\n    config = GPT2Config()\n    model = GPT2LMHeadModel(config)\n    criterion = GPTLMLoss()\n    optimizer = HybridAdam(model.parameters(), nvme_offload_fraction=nvme_offload_fraction)\n    print(f'Model numel: {get_model_numel(model) / 1024**3:.3f} B')\n\n    start = time.time()\n    for step in range(3):\n        data = get_data(4, 128, config.vocab_size, device='cpu')\n        outputs = model(**data)\n        loss = criterion(outputs.logits, data['input_ids'])\n        loss.backward()\n        optimizer.step()\n        optimizer.zero_grad()\n        print(f'[{step}] loss: {loss.item():.3f}')\n\n    print(f'Time: {time.time() - start:.3f} s')\n    print(f'Mem usage: {get_mem_usage() / 1024**2:.3f} MB')\n")),(0,a.kt)("p",null,"Run without NVME offload:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"train_cpu(0.0)\n")),(0,a.kt)("p",null,"We may get below output:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Model numel: 0.116 B\n[0] loss: 10.953\n[1] loss: 10.974\n[2] loss: 10.965\nTime: 7.739 s\nMem usage: 5966.445 MB\n")),(0,a.kt)("p",null,"And then run with (full) NVME offload:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"train_cpu(1.0)\n")),(0,a.kt)("p",null,"We may get:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Model numel: 0.116 B\n[0] loss: 10.951\n[1] loss: 10.994\n[2] loss: 10.984\nTime: 8.527 s\nMem usage: 4968.016 MB\n")),(0,a.kt)("p",null,"For GPT2-S, which has 0.116 billion parameters, its optimizer states take about 0.928 GB memory. And NVME offload saves about 998 MB memory, which meets our expectations."),(0,a.kt)("p",null,"Then we can train GPT model with Gemini. The placement policy of Gemini should be ",(0,a.kt)("inlineCode",{parentName:"p"},'"auto"'),", ",(0,a.kt)("inlineCode",{parentName:"p"},'"cpu"')," or ",(0,a.kt)("inlineCode",{parentName:"p"},'"const"'),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def train_gemini_cpu(nvme_offload_fraction: float = 0.0):\n    colossalai.launch_from_torch({})\n    config = GPT2Config()\n    with ColoInitContext(device=torch.cuda.current_device()):\n        model = GPT2LMHeadModel(config)\n    criterion = GPTLMLoss()\n    optimizer = HybridAdam(model.parameters(), nvme_offload_fraction=nvme_offload_fraction)\n    print(f'Model numel: {get_model_numel(model) / 1024**3:.3f} B')\n\n    gemini_config = dict(strict_ddp_mode=True, device=torch.cuda.current_device(),\n                         placement_policy='cpu', pin_memory=True, hidden_dim=config.n_embd)\n    model = zero_model_wrapper(model, zero_stage=3, gemini_config=gemini_config)\n    optimizer = zero_optim_wrapper(model, optimizer, initial_scale=2**5)\n\n    start = time.time()\n    for step in range(3):\n        data = get_data(4, 128, config.vocab_size)\n        outputs = model(**data)\n        loss = criterion(outputs.logits, data['input_ids'])\n        optimizer.backward(loss)\n        optimizer.step()\n        optimizer.zero_grad()\n        print(f'[{step}] loss: {loss.item():.3f}')\n\n    print(f'Time: {time.time() - start:.3f} s')\n    print(f'Mem usage: {get_mem_usage() / 1024**2:.3f} MB')\n")),(0,a.kt)("p",null,"Run without NVME offload:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"train_gemini_cpu(0.0)\n")),(0,a.kt)("p",null,"We may get:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Model numel: 0.116 B\nsearching chunk configuration is completed in 0.27 s.\nused number: 118.68 MB, wasted number: 0.75 MB\ntotal wasted percentage is 0.63%\n[0] loss: 10.953\n[1] loss: 10.938\n[2] loss: 10.969\nTime: 2.997 s\nMem usage: 5592.227 MB\n")),(0,a.kt)("p",null,"And run with (full) NVME offload:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"train_gemini_cpu(1.0)\n")),(0,a.kt)("p",null,"We may get:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Model numel: 0.116 B\nsearching chunk configuration is completed in 0.27 s.\nused number: 118.68 MB, wasted number: 0.75 MB\ntotal wasted percentage is 0.63%\n[0] loss: 10.953\n[1] loss: 10.938\n[2] loss: 10.969\nTime: 3.691 s\nMem usage: 5298.344 MB\n")),(0,a.kt)("p",null,"NVME offload saves about 294 MB memory. Note that enabling ",(0,a.kt)("inlineCode",{parentName:"p"},"pin_memory")," of Gemini can accelerate training but increase memory usage. So this result also meets our expectation. If we disable ",(0,a.kt)("inlineCode",{parentName:"p"},"pin_memory"),", we can aslo observe a memory usage drop about 900 MB."),(0,a.kt)("h2",{id:"api-reference"},"API Reference"),(0,a.kt)("p",null,"{{ autodoc:colossalai.nn.optimizer.HybridAdam }}"),(0,a.kt)("p",null,"{{ autodoc:colossalai.nn.optimizer.CPUAdam }}"))}c.isMDXComponent=!0}}]);