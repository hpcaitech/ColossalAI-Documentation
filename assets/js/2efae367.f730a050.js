"use strict";(self.webpackChunkagile_docs=self.webpackChunkagile_docs||[]).push([[4134],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return d}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(n),d=i,h=u["".concat(s,".").concat(d)]||u[d]||m[d]||o;return n?a.createElement(h,r(r({ref:t},c),{},{components:n})):a.createElement(h,r({ref:t},c))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9079:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return c},default:function(){return u}});var a=n(3117),i=n(102),o=(n(7294),n(3905)),r=["components"],l={},s="Auto Mixed Precision Training",p={unversionedId:"features/mixed_precision_training",id:"version-v0.2.2/features/mixed_precision_training",title:"Auto Mixed Precision Training",description:"Author: Chuanrui Wang, Shenggui Li, Yongbin Li",source:"@site/i18n/en/docusaurus-plugin-content-docs/version-v0.2.2/features/mixed_precision_training.md",sourceDirName:"features",slug:"/features/mixed_precision_training",permalink:"/docs/features/mixed_precision_training",tags:[],version:"v0.2.2",frontMatter:{}},c=[{value:"Introduction",id:"introduction",children:[],level:2},{value:"Table of Contents",id:"table-of-contents",children:[],level:2},{value:"AMP Introduction",id:"amp-introduction",children:[],level:2},{value:"AMP in Colossal-AI",id:"amp-in-colossal-ai",children:[{value:"AMP Modularity",id:"amp-modularity",children:[],level:3},{value:"Torch AMP Configuration",id:"torch-amp-configuration",children:[],level:3},{value:"Apex AMP Configuration",id:"apex-amp-configuration",children:[],level:3},{value:"Naive AMP Configuration",id:"naive-amp-configuration",children:[],level:3}],level:2},{value:"Hands-on Practice",id:"hands-on-practice",children:[{value:"Step 1. Create a config file",id:"step-1-create-a-config-file",children:[],level:3},{value:"Step 2. Import libraries in train_with_engine.py",id:"step-2-import-libraries-in-train_with_enginepy",children:[],level:3},{value:"Step 3. Initialize Distributed Environment",id:"step-3-initialize-distributed-environment",children:[],level:3},{value:"Step 4. Create training components",id:"step-4-create-training-components",children:[],level:3},{value:"Step 5. Inject AMP Feature",id:"step-5-inject-amp-feature",children:[],level:3},{value:"Step 6. Train with Engine",id:"step-6-train-with-engine",children:[],level:3},{value:"Step 7. Invoke Training Scripts",id:"step-7-invoke-training-scripts",children:[],level:3}],level:2}],m={toc:c};function u(e){var t=e.components,n=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"auto-mixed-precision-training"},"Auto Mixed Precision Training"),(0,o.kt)("p",null,"Author: Chuanrui Wang, Shenggui Li, Yongbin Li"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Prerequisite")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/docs/basics/define_your_config"},"Define Your Configuration")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/docs/basics/engine_trainer"},"Use Engine and Trainer in Training"))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example Code")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/hpcaitech/ColossalAI-Examples/tree/main/features/amp"},"ColossalAI-Examples AMP"))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Related Paper")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://arxiv.org/abs/0808.2794"},"Accelerating Scientific Computations with Mixed Precision Algorithms"))),(0,o.kt)("h2",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"AMP stands for automatic mixed precision training.\nIn Colossal-AI, we have incorporated different implementations of mixed precision training:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"torch.cuda.amp"),(0,o.kt)("li",{parentName:"ol"},"apex.amp"),(0,o.kt)("li",{parentName:"ol"},"naive amp")),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Colossal-AI"),(0,o.kt)("th",{parentName:"tr",align:null},"support tensor parallel"),(0,o.kt)("th",{parentName:"tr",align:null},"support pipeline parallel"),(0,o.kt)("th",{parentName:"tr",align:null},"fp16 extent"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"AMP_TYPE.TORCH"),(0,o.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,o.kt)("td",{parentName:"tr",align:null},"\u274c"),(0,o.kt)("td",{parentName:"tr",align:null},"Model parameters, activation, gradients are downcast to fp16 during forward and backward propagation")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"AMP_TYPE.APEX"),(0,o.kt)("td",{parentName:"tr",align:null},"\u274c"),(0,o.kt)("td",{parentName:"tr",align:null},"\u274c"),(0,o.kt)("td",{parentName:"tr",align:null},"More fine-grained, we can choose opt_level O0, O1, O2, O3")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"AMP_TYPE.NAIVE"),(0,o.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,o.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,o.kt)("td",{parentName:"tr",align:null},"Model parameters, forward and backward operations are all downcast to fp16")))),(0,o.kt)("p",null,"The first two rely on the original implementation of PyTorch (version 1.6 and above) and NVIDIA Apex.\nThe last method is similar to Apex O2 level.\nAmong these methods, apex AMP is not compatible with tensor parallelism.\nThis is because that tensors are split across devices in tensor parallelism, thus, it is required to communicate among different processes to check if inf or nan occurs in the whole model weights.\nWe modified the torch amp implementation so that it is compatible with tensor parallelism now."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"\u274c\ufe0f fp16 and zero configuration are not compatible"),(0,o.kt)("p",{parentName:"blockquote"},"\u26a0\ufe0f Pipeline only support naive AMP currently")),(0,o.kt)("p",null,"We recommend you to use torch AMP as it generally gives better accuracy than naive AMP if no pipeline is used."),(0,o.kt)("h2",{id:"table-of-contents"},"Table of Contents"),(0,o.kt)("p",null,"In this tutorial we will cover:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"AMP introduction"),(0,o.kt)("li",{parentName:"ol"},"AMP in Colossal-AI"),(0,o.kt)("li",{parentName:"ol"},"Hands-on Practice")),(0,o.kt)("h2",{id:"amp-introduction"},"AMP Introduction"),(0,o.kt)("p",null,"Automatic Mixed Precision training is a mixture of FP16 and FP32 training."),(0,o.kt)("p",null,"Half-precision float point format (FP16) has lower arithmetic complexity and higher compute efficiency.\nBesides, fp16 requires half of the storage needed by fp32 and saves memory & network bandwidth, which makes more memory\navailable for large batch size and model size."),(0,o.kt)("p",null,"However, there are other operations, like reductions, which require the dynamic range of fp32 to avoid numeric overflow/underflow. That's the reason why we introduce automatic mixed precision, attempting to match each operation to its appropriate data type, which can reduce the memory footprint and augment training efficiency."),(0,o.kt)("figure",{style:{textAlign:"center"}},(0,o.kt)("img",{src:"https://s2.loli.net/2022/01/28/URzLJ3MPeDQbtck.png"}),(0,o.kt)("figcaption",null,"Illustration of an ordinary AMP (figure from ",(0,o.kt)("a",{href:"https://arxiv.org/abs/2108.05818"},"PatrickStar paper"),")")),(0,o.kt)("h2",{id:"amp-in-colossal-ai"},"AMP in Colossal-AI"),(0,o.kt)("p",null,"We supported three AMP training methods and allowed the user to train with AMP with no code. You can just simply add ",(0,o.kt)("inlineCode",{parentName:"p"},"fp16"),"\nconfiguration in your configuration file to use AMP."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"from colossalai.amp import AMP_TYPE\n\n# use Torch AMP\nfp16=dict(\n    mode = AMP_TYPE.TORCH\n)\n\n# use naive AMP\nfp16=dict(\n    mode = AMP_TYPE.NAIVE\n)\n\n# use NVIDIA Apex AMP\nfp16=dict(\n    mode = AMP_TYPE.APEX\n)\n\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"These are the minimum configuration, full configuration are stated in the section later")),(0,o.kt)("h3",{id:"amp-modularity"},"AMP Modularity"),(0,o.kt)("p",null,"AMP module is designed to be completely modular and can be used independently.\nIf you wish to only use AMP in your code base without ",(0,o.kt)("inlineCode",{parentName:"p"},"colossalai.initialize"),",\nyou can use ",(0,o.kt)("inlineCode",{parentName:"p"},"colossalai.amp.convert_to_amp"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"from colossalai.amp import AMP_TYPE\n\n# exmaple of using torch amp\nmodel, optimizer, criterion = colossalai.amp.convert_to_amp(model,\n                                                            optimizer,\n                                                            criterion,\n                                                            AMP_TYPE.TORCH)\n")),(0,o.kt)("h3",{id:"torch-amp-configuration"},"Torch AMP Configuration"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"from colossalai.amp import AMP_TYPE\n\nfp16=dict(\n    mode=AMP_TYPE.TORCH,\n\n    # below are default values for grad scaler\n    init_scale=2.**16,\n    growth_factor=2.0,\n    backoff_factor=0.5,\n    growth_interval=2000,\n    enabled=True\n)\n")),(0,o.kt)("p",null,"With optional arguments:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"init_scale(float, optional, default=2.**16): Initial scale factor"),(0,o.kt)("li",{parentName:"ul"},"growth_factor(float, optional, default=2.0): Factor by which the scale is multiplied during ",(0,o.kt)("inlineCode",{parentName:"li"},"update")," if no inf/NaN gradients occur for ",(0,o.kt)("inlineCode",{parentName:"li"},"growth_interval")," consecutive iterations."),(0,o.kt)("li",{parentName:"ul"},"backoff_factor(float, optional, default=0.5): Factor by which the scale is multiplied during ",(0,o.kt)("inlineCode",{parentName:"li"},"update")," if inf/NaN gradients occur in an iteration."),(0,o.kt)("li",{parentName:"ul"},"growth_interval(int, optional, default=2000): Number of consecutive iterations without inf/NaN gradients that must occur for the scale to be multiplied by ",(0,o.kt)("inlineCode",{parentName:"li"},"growth_factor"),"."),(0,o.kt)("li",{parentName:"ul"},"enabled(bool, optional, default=True): If ",(0,o.kt)("inlineCode",{parentName:"li"},"False"),", disables gradient scaling. ",(0,o.kt)("inlineCode",{parentName:"li"},"step")," simply invokes the underlying ",(0,o.kt)("inlineCode",{parentName:"li"},"optimizer.step()"),", and other methods become no-ops.")),(0,o.kt)("h3",{id:"apex-amp-configuration"},"Apex AMP Configuration"),(0,o.kt)("p",null,"For this mode, we rely on the Apex implementation for mixed precision training.\nWe support this plugin because it allows for finer control on the granularity of mixed precision.\nFor example, O2 level (optimization level 2) will keep batch normalization in fp32."),(0,o.kt)("p",null,"If you look for more details, please refer to ",(0,o.kt)("a",{parentName:"p",href:"https://nvidia.github.io/apex/"},"Apex Documentation"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"from colossalai.amp import AMP_TYPE\n\nfp16 = dict(\n    mode=AMP_TYPE.APEX,\n\n    # below are the default values\n    enabled=True,\n    opt_level='O1',\n    cast_model_type=None,\n    patch_torch_functions=None,\n    keep_batchnorm_fp32=None,\n    master_weights=None,\n    loss_scale=None,\n    cast_model_outputs=None,\n    num_losses=1,\n    verbosity=1,\n    min_loss_scale=None,\n    max_loss_scale=16777216.0\n)\n")),(0,o.kt)("p",null,"Parameters:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"enabled(bool, optional, default=True): If False, renders all AMP calls no-ops, so your script should run as if Amp were not present.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},'opt_level(str, optional, default="O1" ): Pure or mixed precision optimization level.\nAccepted values are \u201cO0\u201d, \u201cO1\u201d, \u201cO2\u201d, and \u201cO3\u201d, explained in detail above Apex AMP Documentation.')),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"num_losses(int, optional, default=1): Option to tell AMP in advance how many losses/backward passes you plan to use.\nWhen used in conjunction with the loss_id argument to ",(0,o.kt)("inlineCode",{parentName:"p"},"amp.scale_loss"),", enables Amp to use a different loss scale per\nloss/backward pass, which can improve stability. If num_losses is left to 1, Amp will still support multiple\nlosses/backward passes, but use a single global loss scale for all of them.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"verbosity(int, default=1): Set to 0 to suppress Amp-related output.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"min_loss_scale(float, default=None): Sets a floor for the loss scale values that can be chosen by dynamic loss scaling.\nThe default value of None means that no floor is imposed. If dynamic loss scaling is not used, min_loss_scale is ignored.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"max_loss_scale(float, default=2.**24 ): Sets a ceiling for the loss scale values that can be chosen by dynamic loss\nscaling. If dynamic loss scaling is not used, max_loss_scale is ignored."))),(0,o.kt)("p",null,"Currently, the under-the-hood properties that govern pure or mixed precision training are the following:\ncast_model_type, patch_torch_functions, keep_batchnorm_fp32, master_weights, loss_scale.\nThey are optional properties override once opt_level is determined"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"cast_model_type: Casts your model\u2019s parameters and buffers to the desired type."),(0,o.kt)("li",{parentName:"ul"},"patch_torch_functions: Patch all Torch functions and Tensor methods to perform Tensor Core-friendly ops like GEMMs and convolutions in FP16, and any ops that benefit from FP32 precision in FP32."),(0,o.kt)("li",{parentName:"ul"},"keep_batchnorm_fp32: To enhance precision and enable cudnn batchnorm (which improves performance), it\u2019s often beneficial to keep batchnorm weights in FP32 even if the rest of the model is FP16."),(0,o.kt)("li",{parentName:"ul"},"master_weights: Maintain FP32 master weights to accompany any FP16 model weights. FP32 master weights are stepped by the optimizer to enhance precision and capture small gradients."),(0,o.kt)("li",{parentName:"ul"},'loss_scale: If loss_scale is a float value, use this value as the static (fixed) loss scale. If loss_scale is the string "dynamic", adaptively adjust the loss scale over time. Dynamic loss scale adjustments are performed by Amp automatically.')),(0,o.kt)("h3",{id:"naive-amp-configuration"},"Naive AMP Configuration"),(0,o.kt)("p",null,"In Naive AMP mode, we achieved mixed precision training while maintaining compatibility with complex tensor and pipeline parallelism.\nThis AMP mode will cast all operations into fp16.\nThe following code block shows the ",(0,o.kt)("inlineCode",{parentName:"p"},"config.py")," file for this mode."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"from colossalai.amp import AMP_TYPE\n\nfp16 = dict(\n    mode=AMP_TYPE.NAIVE,\n\n    # below are the default values\n    log_num_zeros_in_grad=False,\n    initial_scale=2 ** 32,\n    min_scale=1,\n    growth_factor=2,\n    backoff_factor=0.5,\n    growth_interval=1000,\n    hysteresis=2\n)\n")),(0,o.kt)("p",null,"The default parameters of Naive AMP:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"log_num_zeros_in_grad(bool): return number of zeros in the gradients."),(0,o.kt)("li",{parentName:"ul"},"initial_scale(int): initial scale of gradient scaler"),(0,o.kt)("li",{parentName:"ul"},"growth_factor(int): the growth rate of loss scale"),(0,o.kt)("li",{parentName:"ul"},"backoff_factor(float): the decrease rate of loss scale"),(0,o.kt)("li",{parentName:"ul"},"hysterisis(int): delay shift in dynamic loss scaling"),(0,o.kt)("li",{parentName:"ul"},"max_scale(int): maximum loss scale allowed"),(0,o.kt)("li",{parentName:"ul"},"verbose(bool): if set to ",(0,o.kt)("inlineCode",{parentName:"li"},"True"),", will print debug info")),(0,o.kt)("p",null,"When using ",(0,o.kt)("inlineCode",{parentName:"p"},"colossalai.initialize"),", you are required to first instantiate a model, an optimizer and a criterion.\nThe output model is converted to AMP model of smaller memory consumption.\nIf your input model is already too large to fit in a GPU, please instantiate your model weights in ",(0,o.kt)("inlineCode",{parentName:"p"},"dtype=torch.float16"),".\nOtherwise, try smaller models or checkout more parallelization training techniques!"),(0,o.kt)("h2",{id:"hands-on-practice"},"Hands-on Practice"),(0,o.kt)("p",null,"We provide a ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/hpcaitech/ColossalAI-Examples/tree/main/features/amp"},"runnable example")," which demonstrates\nthe use of AMP with Colossal-AI. In this practice, we will use Torch AMP as an example, but do note that config files are provided for all AMP modes."),(0,o.kt)("h3",{id:"step-1-create-a-config-file"},"Step 1. Create a config file"),(0,o.kt)("p",null,"Create a ",(0,o.kt)("inlineCode",{parentName:"p"},"config.py")," and add the ",(0,o.kt)("inlineCode",{parentName:"p"},"fp16")," configuration."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"# in config.py\nfrom colossalai.amp import AMP_TYPE\n\nBATCH_SIZE = 128\nDROP_RATE = 0.1\nNUM_EPOCHS = 300\n\nfp16 = dict(\n    mode=AMP_TYPE.TORCH,\n)\n\nclip_grad_norm = 1.0\n")),(0,o.kt)("h3",{id:"step-2-import-libraries-in-train_with_enginepy"},"Step 2. Import libraries in train_with_engine.py"),(0,o.kt)("p",null,"Create a ",(0,o.kt)("inlineCode",{parentName:"p"},"train_with_engine.py")," and import the necessary dependencies. Remember to install ",(0,o.kt)("inlineCode",{parentName:"p"},"scipy")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"timm")," by running\n",(0,o.kt)("inlineCode",{parentName:"p"},"pip install timm scipy"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"import os\nimport colossalai\nimport torch\nfrom pathlib import Path\nfrom colossalai.core import global_context as gpc\nfrom colossalai.logging import get_dist_logger\nfrom colossalai.utils import get_dataloader\nfrom colossalai.trainer import Trainer, hooks\nfrom colossalai.nn.lr_scheduler import LinearWarmupLR\nfrom timm.models import vit_base_patch16_224\nfrom torchvision import datasets, transforms\n\n")),(0,o.kt)("h3",{id:"step-3-initialize-distributed-environment"},"Step 3. Initialize Distributed Environment"),(0,o.kt)("p",null,"We then need to initialize distributed environment. For demo purpose, we uses ",(0,o.kt)("inlineCode",{parentName:"p"},"launch_from_torch"),". You can refer to ",(0,o.kt)("a",{parentName:"p",href:"/docs/basics/launch_colossalai"},"Launch Colossal-AI"),"\nfor other initialization methods."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"# initialize distributed setting\nparser = colossalai.get_default_parser()\nargs = parser.parse_args()\n\n# launch from torch\ncolossalai.launch_from_torch(config=args.config)\n\n")),(0,o.kt)("h3",{id:"step-4-create-training-components"},"Step 4. Create training components"),(0,o.kt)("p",null,"Build your model, optimizer, loss function, lr scheduler and dataloaders. Note that the root path of the dataset is\nobtained from the environment varialbe ",(0,o.kt)("inlineCode",{parentName:"p"},"DATA"),". You may ",(0,o.kt)("inlineCode",{parentName:"p"},"export DATA=/path/to/data")," or change ",(0,o.kt)("inlineCode",{parentName:"p"},"Path(os.environ['DATA'])"),"\nto a path on your machine. Data will be automatically downloaded to the root path."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"# build model\n    model = vit_base_patch16_224(drop_rate=0.1)\n\n    # build dataloader\n    train_dataset = datasets.Caltech101(\n        root=Path(os.environ['DATA']),\n        download=True,\n        transform=transforms.Compose([\n            transforms.Resize(256),\n            transforms.RandomResizedCrop(224),\n            transforms.RandomHorizontalFlip(),\n            transforms.ToTensor(),\n            Gray2RGB(),\n            transforms.Normalize([0.5, 0.5, 0.5],\n                                 [0.5, 0.5, 0.5])\n        ]))\n\n    train_dataloader = get_dataloader(dataset=train_dataset,\n                                      shuffle=True,\n                                      batch_size=gpc.config.BATCH_SIZE,\n                                      num_workers=1,\n                                      pin_memory=True,\n                                      )\n\n    # build optimizer\n    optimizer = torch.optim.SGD(model.parameters(), lr=1e-2, weight_decay=0.1)\n\n    # build loss\n    criterion = torch.nn.CrossEntropyLoss()\n\n    # lr_scheduelr\n    lr_scheduler = LinearWarmupLR(optimizer, warmup_steps=50, total_steps=gpc.config.NUM_EPOCHS)\n")),(0,o.kt)("h3",{id:"step-5-inject-amp-feature"},"Step 5. Inject AMP Feature"),(0,o.kt)("p",null,"Call ",(0,o.kt)("inlineCode",{parentName:"p"},"colossalai.initialize")," to convert the training components to be running with FP16."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"engine, train_dataloader, _, _ = colossalai.initialize(\n        model, optimizer, criterion, train_dataloader,\n    )\n")),(0,o.kt)("h3",{id:"step-6-train-with-engine"},"Step 6. Train with Engine"),(0,o.kt)("p",null,"Use engine in a normal training loops."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"engine.train()\nfor epoch in range(gpc.config.NUM_EPOCHS):\n    for img, label in enumerate(train_dataloader):\n        img = img.cuda()\n        label = label.cuda()\n        engine.zero_grad()\n        output = engine(img)\n        loss = engine.criterion(output, label)\n        engine.backward(loss)\n        engine.step()\n        lr_scheduler.step()\n")),(0,o.kt)("h3",{id:"step-7-invoke-training-scripts"},"Step 7. Invoke Training Scripts"),(0,o.kt)("p",null,"Use the following command to start the training scripts. You can change ",(0,o.kt)("inlineCode",{parentName:"p"},"--nproc_per_node")," to use a different number of GPUs."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"python -m torch.distributed.launch --nproc_per_node 4 --master_addr localhost --master_port 29500 train_with_engine.py --config config/config_AMP_torch.py\n")))}u.isMDXComponent=!0}}]);